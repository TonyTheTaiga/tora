import { json, type RequestEvent } from "@sveltejs/kit";
import type { RequestHandler } from "./$types";
import type { Json } from "$lib/server/database.types";
import type { Metric } from "$lib/types";
import { generateRequestId, startTimer } from "$lib/utils/timing";

interface MetricInput {
  name: string;
  value: number;
  metadata?: Json;
  step?: number;
}

interface APIResponse {
  success: boolean;
  error?: {
    message: string;
    code: string;
  };
}

export const POST: RequestHandler = async ({ request, params, locals }) => {
  const userId = locals.user?.id;
  const experimentId = params.slug;

  if (!experimentId?.trim()) {
    return json(
      {
        success: false,
        error: {
          message: "Invalid experiment ID",
          code: "INVALID_ID",
        },
      },
      { status: 400 },
    );
  }

  try {
    await locals.dbClient.checkExperimentAccess(experimentId, userId);
  } catch (error) {
    return json(
      {
        success: false,
        error: {
          message: "Access denied to experiment",
          code: "ACCESS_DENIED",
        },
      },
      { status: 403 },
    );
  }
  try {
    const payload = (await request.json()) as MetricInput;

    if (!payload.name?.trim()) {
      throw new Error("Metric name is required");
    }

    if (payload.value === undefined || payload.value === null) {
      throw new Error("Metric value is required");
    }

    // Experiment ID already validated above

    if (payload.step !== undefined && !Number.isFinite(payload.step)) {
      throw new Error("Step must be a finite number");
    }

    await locals.dbClient.createMetric({
      id: 0, // This will be auto-generated by the database
      experiment_id: experimentId,
      name: payload.name,
      value: payload.value,
      step: payload.step,
      metadata: payload.metadata,
      created_at: new Date().toISOString(), // Set current date as ISO string
    } as Metric);

    return json({
      success: true,
    } satisfies APIResponse);
  } catch (error) {
    const statusCode = error instanceof Error ? 400 : 500;

    return json(
      {
        success: false,
        error: {
          message:
            error instanceof Error ? error.message : "Internal server error",
          code: "METRIC_CREATE_FAILED",
        },
      } satisfies APIResponse,
      { status: statusCode },
    );
  }
};

export const GET: RequestHandler = async ({ params, locals }) => {
  const requestId = generateRequestId();
  const timer = startTimer("api.metrics.GET", { requestId, experimentId: params.slug });
  
  try {
    const userId = locals.user?.id;
    
    try {
      await locals.dbClient.checkExperimentAccess(params.slug, userId);
    } catch (error) {
      timer.end({ error: "Access denied", userId });
      return json([], { status: 200 });
    }

    const metrics = await locals.dbClient.getMetrics(params.slug);
    timer.end({ userId, metricsCount: metrics.length });
    return json(metrics);
  } catch (error) {
    timer.end({ error: error instanceof Error ? error.message : "Unknown error" });
    throw error;
  }
};
